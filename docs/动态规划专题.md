# 动态规划（经典中的经典）

动态规划可以解决问题的条件：
+ 该问题可以拆分为子问题

**动规五部曲**分别为：

1. 确定dp数组（dp table）以及下标的含义，通常dp数组里的数为当前情况下的最优值
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

+ 常见题目：
    + 背包问题

		+ 01背包：
		1. 二维数组。dp[i][j]表示（0-i）个物品放在重量为j的背包中的最大价值。遍历物品。迭代公式：1. =dp[i-1][j]不放物品i（因为放了物品i超重了）2.=dp[i-1][j-weight[i]]+ value[i]。
		2. 优化变成一维数组，注意j循环是从大递减到nums[i]。记录一下迭代循环：
		```c++
		for(int i = 0; i < weight.size(); i++) { // 遍历物品
			for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
				dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
			}
		}
		```
		3. 相关练习:
			+ [分割等和子数组](https://leetcode.cn/problems/partition-equal-subset-sum/submissions/)
		+ 完全背包：每个物品有无限个。可以无限放。
		将上述代码中的循环改为：
		```c++
		// 先遍历物品，再遍历背包
		for(int i = 0; i < weight.size(); i++) { // 遍历物品
			for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
				dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

			}
		}
		```
    + 打家劫舍
		+ 如果dp[i]需要考虑dp[i-2]和dp[i-3]谁大。为什么不考虑dpp[i-4]？因为按照规则，i-2和i-4间隔一家，所以dp[i-2]肯定比dp[i-4]大。
		+ 最后返回值也是如此考虑，最后一家被偷或者最后一家不被偷两种情况的最大值。
		+ 绕圈：考虑三种情况取最大值即可。
		+ 二叉树：考虑一个长度为2（make_pair）的数组。记录偷或者不偷的最大金额。终止条件： cur == nullptr return {0, 0};
    + 股票问题
    + 子序列问题
    + 回文

+ 剑指offer分类：

	+ 面试题10：斐波那契数列
	+ 面试题14：剪绳子
	+ 面试题42：连续子数组的最大和
	+ 面试题46：把数字翻译成字符串
	+ 面试题47：礼物的最大价值
	+ 面试题48：最长不含重复字符的子字符串

参考carl整理的：[dp总结](https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97)

